# Chapter 5: Tool Use (Function Calling)

# Tool Use Pattern Í∞úÏöî

ÏßÄÍ∏àÍπåÏßÄ Ï£ºÎ°ú Ïñ∏Ïñ¥ Î™®Îç∏ Í∞ÑÏùò ÏÉÅÌò∏ÏûëÏö©ÏùÑ Ï°∞Ïú®ÌïòÍ≥† Agent ÎÇ¥Î∂Ä ÏõåÌÅ¨ÌîåÎ°úÏö∞ ÎÇ¥ÏóêÏÑú Ï†ïÎ≥¥ ÌùêÎ¶ÑÏùÑ Í¥ÄÎ¶¨ÌïòÎäî agentic patternÎì§(Chaining, Routing, Parallelization, Reflection)ÏùÑ Îã§Î§òÏùå. ÌïòÏßÄÎßå AgentÍ∞Ä ÏßÑÏ†ïÏúºÎ°ú Ïú†Ïö©ÌïòÍ≥† Ïã§Ï†ú ÏÑ∏Í≥ÑÎÇò Ïô∏Î∂Ä ÏãúÏä§ÌÖúÍ≥º ÏÉÅÌò∏ÏûëÏö©ÌïòÎ†§Î©¥ ToolÏùÑ ÏÇ¨Ïö©Ìï† Ïàò ÏûàÎäî Îä•Î†•Ïù¥ ÌïÑÏöîÌï®.

Tool Use patternÏùÄ ÌùîÌûà Function CallingÏù¥ÎùºÎäî Î©îÏª§ÎãàÏ¶òÏùÑ ÌÜµÌï¥ Íµ¨ÌòÑÎêòÎ©∞, AgentÍ∞Ä Ïô∏Î∂Ä API, Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§, ÏÑúÎπÑÏä§ÏôÄ ÏÉÅÌò∏ÏûëÏö©ÌïòÍ±∞ÎÇò ÏΩîÎìúÎ•º Ïã§ÌñâÌï† Ïàò ÏûàÍ≤å Ìï®. Ïù¥Î•º ÌÜµÌï¥ Agent ÌïµÏã¨Ïóê ÏûàÎäî LLMÏù¥ ÏÇ¨Ïö©Ïûê ÏöîÏ≤≠Ïù¥ÎÇò ÏûëÏóÖÏùò ÌòÑÏû¨ ÏÉÅÌÉúÎ•º Í∏∞Î∞òÏúºÎ°ú ÌäπÏ†ï Ïô∏Î∂Ä Ìï®ÏàòÎ•º Ïñ∏Ï†ú Ïñ¥ÎñªÍ≤å ÏÇ¨Ïö©Ìï†ÏßÄ Í≤∞Ï†ïÌï† Ïàò ÏûàÏùå.

ÌîÑÎ°úÏÑ∏Ïä§Îäî ÏùºÎ∞òÏ†ÅÏúºÎ°ú Îã§ÏùåÏùÑ Ìè¨Ìï®Ìï®:

1. **Tool Ï†ïÏùò:** Ïô∏Î∂Ä Ìï®ÏàòÎÇò Í∏∞Îä•ÏùÑ LLMÏóê Ï†ïÏùòÌïòÍ≥† ÏÑ§Î™ÖÌï®. Ïù¥ ÏÑ§Î™ÖÏóêÎäî Ìï®ÏàòÏùò Î™©Ï†Å, Ïù¥Î¶Ñ, ÌóàÏö©ÌïòÎäî ÌååÎùºÎØ∏ÌÑ∞ÏôÄ Í∑∏ ÌÉÄÏûÖ Î∞è ÏÑ§Î™ÖÏù¥ Ìè¨Ìï®Îê®.
2. **LLM Í≤∞Ï†ï:** LLMÏùÄ ÏÇ¨Ïö©Ïûê ÏöîÏ≤≠Í≥º ÏÇ¨Ïö© Í∞ÄÎä•Ìïú tool Ï†ïÏùòÎ•º Î∞õÏùå. ÏöîÏ≤≠Í≥º toolÏóê ÎåÄÌïú Ïù¥Ìï¥Î•º Î∞îÌÉïÏúºÎ°ú LLMÏùÄ ÏöîÏ≤≠ÏùÑ Ï∂©Ï°±ÌïòÍ∏∞ ÏúÑÌï¥ ÌïòÎÇò Ïù¥ÏÉÅÏùò tool Ìò∏Ï∂úÏù¥ ÌïÑÏöîÌïúÏßÄ Í≤∞Ï†ïÌï®.
3. **Function Call ÏÉùÏÑ±:** LLMÏù¥ toolÏùÑ ÏÇ¨Ïö©ÌïòÍ∏∞Î°ú Í≤∞Ï†ïÌïòÎ©¥, Ìò∏Ï∂úÌï† toolÏùò Ïù¥Î¶ÑÍ≥º ÏÇ¨Ïö©Ïûê ÏöîÏ≤≠ÏóêÏÑú Ï∂îÏ∂úÌïú Ï†ÑÎã¨Ìï† Ïù∏Ïûê(ÌååÎùºÎØ∏ÌÑ∞)Î•º Î™ÖÏãúÌïòÎäî Íµ¨Ï°∞ÌôîÎêú Ï∂úÎ†•(Ï£ºÎ°ú JSON Í∞ùÏ≤¥)ÏùÑ ÏÉùÏÑ±Ìï®.
4. **Tool Ïã§Ìñâ:** Agentic framework ÎòêÎäî orchestration layerÍ∞Ä Ïù¥ Íµ¨Ï°∞ÌôîÎêú Ï∂úÎ†•ÏùÑ Í∞ÄÎ°úÏ±ÑÏÑú ÏöîÏ≤≠Îêú toolÏùÑ ÏãùÎ≥ÑÌïòÍ≥† Ï†úÍ≥µÎêú Ïù∏ÏûêÎ°ú Ïã§Ï†ú Ïô∏Î∂Ä Ìï®ÏàòÎ•º Ïã§ÌñâÌï®.
5. **Í¥ÄÏ∞∞/Í≤∞Í≥º:** Tool Ïã§ÌñâÏùò Ï∂úÎ†• ÎòêÎäî Í≤∞Í≥ºÍ∞Ä AgentÏóêÍ≤å Î∞òÌôòÎê®.
6. **LLM Ï≤òÎ¶¨ (ÏÑ†ÌÉùÏ†ÅÏù¥ÏßÄÎßå ÏùºÎ∞òÏ†Å):** LLMÏùÄ toolÏùò Ï∂úÎ†•ÏùÑ Ïª®ÌÖçÏä§Ìä∏Î°ú Î∞õÏïÑ ÏÇ¨Ïö©ÏûêÏóêÍ≤å ÏµúÏ¢Ö ÏùëÎãµÏùÑ Íµ¨ÏÑ±ÌïòÍ±∞ÎÇò ÏõåÌÅ¨ÌîåÎ°úÏö∞Ïùò Îã§Ïùå Îã®Í≥ÑÎ•º Í≤∞Ï†ïÌï®(Îã§Î•∏ tool Ìò∏Ï∂ú, reflection, ÎòêÎäî ÏµúÏ¢Ö ÎãµÎ≥Ä Ï†úÍ≥µ Ìè¨Ìï® Í∞ÄÎä•).

Ïù¥ patternÏùÄ LLMÏùò ÌïôÏäµ Îç∞Ïù¥ÌÑ∞ Ï†úÏïΩÏùÑ Íπ®Í≥† ÏµúÏã† Ï†ïÎ≥¥ Ï†ëÍ∑º, ÎÇ¥Î∂ÄÏ†ÅÏúºÎ°ú Î∂àÍ∞ÄÎä•Ìïú Í≥ÑÏÇ∞ ÏàòÌñâ, ÏÇ¨Ïö©ÏûêÎ≥Ñ Îç∞Ïù¥ÌÑ∞ÏôÄÏùò ÏÉÅÌò∏ÏûëÏö©, ÎòêÎäî Ïã§Ï†ú ÏÑ∏Í≥ÑÏùò ÌñâÎèô Ìä∏Î¶¨Í±∞Î•º Í∞ÄÎä•ÌïòÍ≤å ÌïòÎØÄÎ°ú Í∑ºÎ≥∏Ï†ÅÏûÑ. Function callingÏùÄ LLMÏùò Ï∂îÎ°† Îä•Î†•Í≥º Ïô∏Î∂ÄÏóêÏÑú ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Í¥ëÎ≤îÏúÑÌïú Í∏∞Îä• Í∞ÑÏùò Í∞ÑÍ∑πÏùÑ Î©îÏö∞Îäî Í∏∞Ïà†Ï†Å Î©îÏª§ÎãàÏ¶òÏûÑ.

"function calling"Ïù¥ ÌäπÏ†ï ÏÇ¨Ï†Ñ Ï†ïÏùòÎêú ÏΩîÎìú Ìï®Ïàò Ìò∏Ï∂úÏùÑ Ï†ÅÏ†àÌûà ÏÑ§Î™ÖÌïòÍ∏¥ ÌïòÏßÄÎßå, Îçî ÌôïÏû•Ï†ÅÏù∏ "tool calling" Í∞úÎÖêÏùÑ Í≥†Î†§ÌïòÎäî Í≤ÉÏù¥ Ïú†Ïö©Ìï®. Ïù¥ ÎÑìÏùÄ Ïö©Ïñ¥Îäî AgentÏùò Îä•Î†•Ïù¥ Îã®Ïàú Ìï®Ïàò Ïã§ÌñâÏùÑ Ìõ®Ïî¨ ÎÑòÏñ¥ÏÑ§ Ïàò ÏûàÏùåÏùÑ Ïù∏Ï†ïÌï®. "tool"ÏùÄ Ï†ÑÌÜµÏ†ÅÏù∏ Ìï®ÏàòÏùº ÏàòÎèÑ ÏûàÏßÄÎßå, Î≥µÏû°Ìïú API endpoint, Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏöîÏ≤≠, ÎòêÎäî Îã§Î•∏ ÌäπÌôîÎêú AgentÏóê ÎåÄÌïú ÏßÄÏãúÏùº ÏàòÎèÑ ÏûàÏùå. Ïù¥Îü¨Ìïú Í¥ÄÏ†êÏùÄ ÏòàÎ•º Îì§Ïñ¥ Ï£º AgentÍ∞Ä Î≥µÏû°Ìïú Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù ÏûëÏóÖÏùÑ Ï†ÑÎã¥ "analyst agent"ÏóêÍ≤å ÏúÑÏûÑÌïòÍ±∞ÎÇò Ïô∏Î∂Ä ÏßÄÏãù Î≤†Ïù¥Ïä§Î•º APIÎ•º ÌÜµÌï¥ ÏøºÎ¶¨ÌïòÎäî Îì± Îçî Ï†ïÍµêÌïú ÏãúÏä§ÌÖúÏùÑ Íµ¨ÏÉÅÌï† Ïàò ÏûàÍ≤å Ìï®. "tool calling"Î°ú ÏÇ¨Í≥†ÌïòÎ©¥ AgentÍ∞Ä Îã§ÏñëÌïú ÎîîÏßÄÌÑ∏ Î¶¨ÏÜåÏä§ÏôÄ Îã§Î•∏ ÏßÄÎä•Ï†Å Í∞úÏ≤¥Ïùò ÏÉùÌÉúÍ≥ÑÏóêÏÑú orchestratorÎ°ú ÏûëÎèôÌï† Ïàò ÏûàÎäî Ï†ÑÏ≤¥ Ïû†Ïû¨Î†•ÏùÑ Îçî Ïûò Ìè¨Ï∞©Ìï®.

LangChain, LangGraph, Google Agent Developer Kit (ADK) Í∞ôÏùÄ frameworkÎì§ÏùÄ tool Ï†ïÏùòÏôÄ Agent ÏõåÌÅ¨ÌîåÎ°úÏö∞Î°úÏùò ÌÜµÌï©ÏùÑ ÏúÑÌïú Í≤¨Í≥†Ìïú ÏßÄÏõêÏùÑ Ï†úÍ≥µÌïòÎ©∞, Ï¢ÖÏ¢Ö GeminiÎÇò OpenAI ÏãúÎ¶¨Ï¶à Í∞ôÏùÄ ÏµúÏã† LLMÏùò ÎÑ§Ïù¥Ìã∞Î∏å function calling Îä•Î†•ÏùÑ ÌôúÏö©Ìï®. Ïù¥Îü¨Ìïú frameworkÏùò "canvas"ÏóêÏÑú toolÏùÑ Ï†ïÏùòÌïú ÌõÑ Agent(ÏùºÎ∞òÏ†ÅÏúºÎ°ú LLM Agent)Í∞Ä Ïù¥Îü¨Ìïú toolÏùÑ Ïù∏ÏãùÌïòÍ≥† ÏÇ¨Ïö©Ìï† Ïàò ÏûàÎèÑÎ°ù Íµ¨ÏÑ±Ìï®.

Tool UseÎäî Í∞ïÎ†•ÌïòÍ≥† ÏÉÅÌò∏ÏûëÏö©Ï†ÅÏù¥Î©∞ Ïô∏Î∂Ä Ïù∏Ïãù AgentÎ•º Íµ¨Ï∂ïÌïòÍ∏∞ ÏúÑÌïú ÌïµÏã¨ patternÏûÑ.

# Ïã§Ïö©Ï†Å ÏùëÏö© Î∞è ÏÇ¨Ïö© ÏÇ¨Î°Ä

Tool Use patternÏùÄ AgentÍ∞Ä ÌÖçÏä§Ìä∏ ÏÉùÏÑ±ÏùÑ ÎÑòÏñ¥ ÌñâÎèôÏùÑ ÏàòÌñâÌïòÍ±∞ÎÇò ÌäπÏ†ï ÎèôÏ†Å Ï†ïÎ≥¥Î•º Í≤ÄÏÉâÌï¥Ïïº ÌïòÎäî Í±∞Ïùò Î™®Îì† ÏãúÎÇòÎ¶¨Ïò§Ïóê Ï†ÅÏö© Í∞ÄÎä•Ìï®:

1\. Ïô∏Î∂Ä ÏÜåÏä§Î°úÎ∂ÄÌÑ∞ Ï†ïÎ≥¥ Í≤ÄÏÉâ:
LLMÏùò ÌïôÏäµ Îç∞Ïù¥ÌÑ∞Ïóê ÏóÜÎäî Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ÎÇò Ï†ïÎ≥¥Ïóê Ï†ëÍ∑º.

* **ÏÇ¨Ïö© ÏÇ¨Î°Ä:** ÎÇ†Ïî® Agent.
  * **Tool:** ÏúÑÏπòÎ•º Î∞õÏïÑ ÌòÑÏû¨ ÎÇ†Ïî® Ï°∞Í±¥ÏùÑ Î∞òÌôòÌïòÎäî ÎÇ†Ïî® API.
  * **Agent ÌùêÎ¶Ñ:** ÏÇ¨Ïö©ÏûêÍ∞Ä "Îü∞Îçò ÎÇ†Ïî®Îäî?" ÏßàÎ¨∏, LLMÏù¥ ÎÇ†Ïî® tool ÌïÑÏöîÏÑ± ÏãùÎ≥Ñ, "London"ÏúºÎ°ú tool Ìò∏Ï∂ú, toolÏù¥ Îç∞Ïù¥ÌÑ∞ Î∞òÌôò, LLMÏù¥ Îç∞Ïù¥ÌÑ∞Î•º ÏÇ¨Ïö©Ïûê ÏπúÌôîÏ†Å ÏùëÎãµÏúºÎ°ú Ìè¨Îß∑ÌåÖ.

2\. Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Î∞è APIÏôÄÏùò ÏÉÅÌò∏ÏûëÏö©:
Íµ¨Ï°∞ÌôîÎêú Îç∞Ïù¥ÌÑ∞Ïóê ÎåÄÌïú ÏøºÎ¶¨, ÏóÖÎç∞Ïù¥Ìä∏ ÎòêÎäî Í∏∞ÌÉÄ ÏûëÏóÖ ÏàòÌñâ.

* **ÏÇ¨Ïö© ÏÇ¨Î°Ä:** Ï†ÑÏûêÏÉÅÍ±∞Îûò Agent.
  * **Tools:** Ï†úÌíà Ïû¨Í≥† ÌôïÏù∏, Ï£ºÎ¨∏ ÏÉÅÌÉú Ï°∞Ìöå, Í≤∞Ï†ú Ï≤òÎ¶¨Î•º ÏúÑÌïú API Ìò∏Ï∂ú.
  * **Agent ÌùêÎ¶Ñ:** ÏÇ¨Ïö©ÏûêÍ∞Ä "Ï†úÌíà X Ïû¨Í≥† ÏûàÎÇòÏöî?" ÏßàÎ¨∏, LLMÏù¥ Ïû¨Í≥† API Ìò∏Ï∂ú, toolÏù¥ Ïû¨Í≥† ÏàòÎüâ Î∞òÌôò, LLMÏù¥ ÏÇ¨Ïö©ÏûêÏóêÍ≤å Ïû¨Í≥† ÏÉÅÌÉú ÏïåÎ¶º.

3\. Í≥ÑÏÇ∞ Î∞è Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù ÏàòÌñâ:
Ïô∏Î∂Ä Í≥ÑÏÇ∞Í∏∞, Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù ÎùºÏù¥Î∏åÎü¨Î¶¨ ÎòêÎäî ÌÜµÍ≥Ñ tool ÏÇ¨Ïö©.

* **ÏÇ¨Ïö© ÏÇ¨Î°Ä:** Í∏àÏúµ Agent.
  * **Tools:** Í≥ÑÏÇ∞Í∏∞ Ìï®Ïàò, Ï£ºÏãù ÏãúÏû• Îç∞Ïù¥ÌÑ∞ API, Ïä§ÌîÑÎ†àÎìúÏãúÌä∏ tool.
  * **Agent ÌùêÎ¶Ñ:** ÏÇ¨Ïö©ÏûêÍ∞Ä "AAPLÏùò ÌòÑÏû¨ Í∞ÄÍ≤©ÏùÄ? $150Ïóê 100Ï£º Îß§Ïàò Ïãú Ïû†Ïû¨Ï†Å Ïù¥Ïùµ Í≥ÑÏÇ∞Ìï¥Ï§ò" ÏßàÎ¨∏, LLMÏù¥ Ï£ºÏãù API Ìò∏Ï∂ú, ÌòÑÏû¨ Í∞ÄÍ≤© ÌöçÎìù, Í≥ÑÏÇ∞Í∏∞ tool Ìò∏Ï∂ú, Í≤∞Í≥º ÌöçÎìù, ÏùëÎãµ Ìè¨Îß∑ÌåÖ.

4\. ÌÜµÏã† Ï†ÑÏÜ°:
Ïù¥Î©îÏùº, Î©îÏãúÏßÄ Ï†ÑÏÜ° ÎòêÎäî Ïô∏Î∂Ä ÌÜµÏã† ÏÑúÎπÑÏä§Ïóê API Ìò∏Ï∂ú.

* **ÏÇ¨Ïö© ÏÇ¨Î°Ä:** Í∞úÏù∏ ÎπÑÏÑú Agent.
  * **Tool:** Ïù¥Î©îÏùº Ï†ÑÏÜ° API.
  * **Agent ÌùêÎ¶Ñ:** ÏÇ¨Ïö©ÏûêÍ∞Ä "ÎÇ¥Ïùº ÌöåÏùòÏóê ÎåÄÌï¥ JohnÏóêÍ≤å Ïù¥Î©îÏùº Î≥¥ÎÇ¥Ï§ò" ÏßÄÏãú, LLMÏù¥ ÏöîÏ≤≠ÏóêÏÑú Ï∂îÏ∂úÌïú ÏàòÏã†Ïûê, Ï†úÎ™©, Î≥∏Î¨∏ÏúºÎ°ú Ïù¥Î©îÏùº tool Ìò∏Ï∂ú.

5\. ÏΩîÎìú Ïã§Ìñâ:
ÏïàÏ†ÑÌïú ÌôòÍ≤ΩÏóêÏÑú ÏΩîÎìú Ïä§ÎãàÌé´ÏùÑ Ïã§ÌñâÌïòÏó¨ ÌäπÏ†ï ÏûëÏóÖ ÏàòÌñâ.

* **ÏÇ¨Ïö© ÏÇ¨Î°Ä:** ÏΩîÎî© Î≥¥Ï°∞ Agent.
  * **Tool:** ÏΩîÎìú Ïù∏ÌÑ∞ÌîÑÎ¶¨ÌÑ∞.
  * **Agent ÌùêÎ¶Ñ:** ÏÇ¨Ïö©ÏûêÍ∞Ä Python Ïä§ÎãàÌé´ÏùÑ Ï†úÍ≥µÌïòÎ©∞ "Ïù¥ ÏΩîÎìúÍ∞Ä Î≠êÌïòÎäî Í±∞Ïïº?" ÏßàÎ¨∏, LLMÏù¥ Ïù∏ÌÑ∞ÌîÑÎ¶¨ÌÑ∞ toolÏùÑ ÏÇ¨Ïö©Ìï¥ ÏΩîÎìú Ïã§Ìñâ Î∞è Ï∂úÎ†• Î∂ÑÏÑù.

6\. Îã§Î•∏ ÏãúÏä§ÌÖú ÎòêÎäî Ïû•Ïπò Ï†úÏñ¥:
Ïä§ÎßàÌä∏Ìôà Ïû•Ïπò, IoT ÌîåÎû´Ìèº ÎòêÎäî Í∏∞ÌÉÄ Ïó∞Í≤∞Îêú ÏãúÏä§ÌÖúÍ≥º ÏÉÅÌò∏ÏûëÏö©.

* **ÏÇ¨Ïö© ÏÇ¨Î°Ä:** Ïä§ÎßàÌä∏Ìôà Agent.
  * **Tool:** Ïä§ÎßàÌä∏ Ï°∞Î™Ö Ï†úÏñ¥ API.
  * **Agent ÌùêÎ¶Ñ:** ÏÇ¨Ïö©ÏûêÍ∞Ä "Í±∞Ïã§ Î∂à Í∫ºÏ§ò" ÏßÄÏãú. LLMÏù¥ Î™ÖÎ†πÍ≥º ÎåÄÏÉÅ Ïû•ÏπòÎ°ú Ïä§ÎßàÌä∏Ìôà tool Ìò∏Ï∂ú.

Tool UseÎäî Ïñ∏Ïñ¥ Î™®Îç∏ÏùÑ ÌÖçÏä§Ìä∏ ÏÉùÏÑ±Í∏∞ÏóêÏÑú ÎîîÏßÄÌÑ∏ ÎòêÎäî Î¨ºÎ¶¨Ï†Å ÏÑ∏Í≥ÑÏóêÏÑú Í∞êÏßÄÌïòÍ≥† Ï∂îÎ°†ÌïòÎ©∞ ÌñâÎèôÌï† Ïàò ÏûàÎäî AgentÎ°ú Î≥ÄÌôòÌïòÎäî ÏöîÏÜåÏûÑ (Fig. 1 Ï∞∏Ï°∞)

![Tool Use Architecture](./images/chapter5/diagram-1.png)

Fig.1: AgentÍ∞Ä ToolsÎ•º ÏÇ¨Ïö©ÌïòÎäî Î™á Í∞ÄÏßÄ ÏòàÏãú

# Ïã§Ïäµ ÏΩîÎìú ÏòàÏ†ú (LangChain)

LangChain framework ÎÇ¥ tool use Íµ¨ÌòÑÏùÄ 2Îã®Í≥Ñ ÌîÑÎ°úÏÑ∏Ïä§ÏûÑ. Ï¥àÍ∏∞Ïóê ÌïòÎÇò Ïù¥ÏÉÅÏùò toolÏùÑ Ï†ïÏùòÌïòÎ©∞, ÏùºÎ∞òÏ†ÅÏúºÎ°ú Í∏∞Ï°¥ Python Ìï®ÏàòÎÇò Îã§Î•∏ Ïã§Ìñâ Í∞ÄÎä•Ìïú Ïª¥Ìè¨ÎÑåÌä∏Î•º Ï∫°ÏäêÌôîÌï®. Ïù¥ÌõÑ Ïù¥Îü¨Ìïú toolÏùÑ Ïñ∏Ïñ¥ Î™®Îç∏Ïóê Î∞îÏù∏Îî©ÌïòÏó¨, Î™®Îç∏Ïù¥ ÏÇ¨Ïö©Ïûê ÏøºÎ¶¨Î•º Ï∂©Ï°±ÌïòÍ∏∞ ÏúÑÌï¥ Ïô∏Î∂Ä Ìï®Ïàò Ìò∏Ï∂úÏù¥ ÌïÑÏöîÌïòÎã§Í≥† ÌåêÎã®Ìï† Îïå Íµ¨Ï°∞ÌôîÎêú tool ÏÇ¨Ïö© ÏöîÏ≤≠ÏùÑ ÏÉùÏÑ±Ìï† Ïàò ÏûàÎäî Îä•Î†•ÏùÑ Î∂ÄÏó¨Ìï®.

Îã§Ïùå Íµ¨ÌòÑÏùÄ Î®ºÏ†Ä Ï†ïÎ≥¥ Í≤ÄÏÉâ toolÏùÑ ÏãúÎÆ¨Î†àÏù¥ÏÖòÌïòÎäî Í∞ÑÎã®Ìïú Ìï®ÏàòÎ•º Ï†ïÏùòÌïòÏó¨ Ïù¥ ÏõêÎ¶¨Î•º Î≥¥Ïó¨Ï§å. Ïù¥ÌõÑ AgentÎ•º Íµ¨Ï∂ïÌïòÍ≥† ÏÇ¨Ïö©Ïûê ÏûÖÎ†•Ïóê ÏùëÎãµÌïòÏó¨ Ïù¥ toolÏùÑ ÌôúÏö©ÌïòÎèÑÎ°ù Íµ¨ÏÑ±Ìï®. Ïù¥ ÏòàÏ†úÏùò Ïã§ÌñâÏùÄ ÌïµÏã¨ LangChain ÎùºÏù¥Î∏åÎü¨Î¶¨ÏôÄ Î™®Îç∏Î≥Ñ provider Ìå®ÌÇ§ÏßÄ ÏÑ§ÏπòÍ∞Ä ÌïÑÏöîÌï®. ÎòêÌïú ÏÑ†ÌÉùÌïú Ïñ∏Ïñ¥ Î™®Îç∏ ÏÑúÎπÑÏä§ÏôÄÏùò Ï†ÅÏ†àÌïú Ïù∏Ï¶ù(ÏùºÎ∞òÏ†ÅÏúºÎ°ú Î°úÏª¨ ÌôòÍ≤ΩÏóê Íµ¨ÏÑ±Îêú API ÌÇ§Î•º ÌÜµÌï¥)Ïù¥ ÌïÑÏàò Ï†ÑÏ†ú Ï°∞Í±¥ÏûÑ.

```python
import os, getpass
import asyncio
import nest_asyncio
from typing import List
from dotenv import load_dotenv
import logging
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.tools import tool as langchain_tool
from langchain.agents import create_tool_calling_agent, AgentExecutor

# UNCOMMENT
# Prompt the user securely and set API keys as an environment variables
os.environ["GOOGLE_API_KEY"] = getpass.getpass("Enter your Google API key: ")
os.environ["OPENAI_API_KEY"] = getpass.getpass("Enter your OpenAI API key: ")

try:
    # A model with function/tool calling capabilities is required.
    llm = ChatGoogleGenerativeAI(model="gemini-2.0-flash", temperature=0)
    print(f"‚úÖ Language model initialized: {llm.model}")
except Exception as e:
    print(f"üõë Error initializing language model: {e}")
    llm = None

# --- Define a Tool ---
@langchain_tool
def search_information(query: str) -> str:
    """
    Provides factual information on a given topic. Use this tool to find answers to phrases
    like 'capital of France' or 'weather in London?'.
    """
    print(f"\n--- üõ†Ô∏è Tool Called: search_information with query: '{query}' ---")
    # Simulate a search tool with a dictionary of predefined results.
    simulated_results = {
        "weather in london": "The weather in London is currently cloudy with a temperature of 15¬∞C.",
        "capital of france": "The capital of France is Paris.",
        "population of earth": "The estimated population of Earth is around 8 billion people.",
        "tallest mountain": "Mount Everest is the tallest mountain above sea level.",
        "default": f"Simulated search result for '{query}': No specific information found, but the topic seems interesting."
    }
    result = simulated_results.get(query.lower(), simulated_results["default"])
    print(f"--- TOOL RESULT: {result} ---")
    return result

tools = [search_information]

# --- Create a Tool-Calling Agent ---
if llm:
    # This prompt template requires an `agent_scratchpad` placeholder for the agent's internal steps.
    agent_prompt = ChatPromptTemplate.from_messages([
        ("system", "You are a helpful assistant."),
        ("human", "{input}"),
        ("placeholder", "{agent_scratchpad}"),
    ])
    # Create the agent, binding the LLM, tools, and prompt together.
    agent = create_tool_calling_agent(llm, tools, agent_prompt)
    # AgentExecutor is the runtime that invokes the agent and executes the chosen tools.
    # The 'tools' argument is not needed here as they are already bound to the agent.
    agent_executor = AgentExecutor(agent=agent, verbose=True, tools=tools)

async def run_agent_with_tool(query: str):
    """Invokes the agent executor with a query and prints the final response."""
    print(f"\n--- üèÉ Running Agent with Query: '{query}' ---")
    try:
        response = await agent_executor.ainvoke({"input": query})
        print("\n--- ‚úÖ Final Agent Response ---")
        print(response["output"])
    except Exception as e:
        print(f"\nüõë An error occurred during agent execution: {e}")

async def main():
    """Runs all agent queries concurrently."""
    tasks = [
        run_agent_with_tool("What is the capital of France?"),
        run_agent_with_tool("What's the weather like in London?"),
        run_agent_with_tool("Tell me something about dogs.") # Should trigger the default tool response
    ]
    await asyncio.gather(*tasks)

nest_asyncio.apply()
asyncio.run(main())
```

ÏΩîÎìúÎäî LangChain ÎùºÏù¥Î∏åÎü¨Î¶¨ÏôÄ Google Gemini Î™®Îç∏ÏùÑ ÏÇ¨Ïö©Ìï¥ tool-calling AgentÎ•º ÏÑ§Ï†ïÌï®. ÌäπÏ†ï ÏøºÎ¶¨Ïóê ÎåÄÌïú ÏÇ¨Ïã§Ï†Å ÎãµÎ≥Ä Ï†úÍ≥µÏùÑ ÏãúÎÆ¨Î†àÏù¥ÏÖòÌïòÎäî search_information toolÏùÑ Ï†ïÏùòÌï®. ToolÏùÄ "weather in london," "capital of france," "population of earth"Ïóê ÎåÄÌïú ÏÇ¨Ï†Ñ Ï†ïÏùòÎêú ÏùëÎãµÍ≥º Í∏∞ÌÉÄ ÏøºÎ¶¨Ïóê ÎåÄÌïú Í∏∞Î≥∏ ÏùëÎãµÏùÑ Í∞ÄÏßê. Tool calling Îä•Î†•Ïù¥ ÏûàÎäî ChatGoogleGenerativeAI Î™®Îç∏ÏùÑ Ï¥àÍ∏∞ÌôîÌï®. AgentÏùò ÏÉÅÌò∏ÏûëÏö©ÏùÑ ÏïàÎÇ¥ÌïòÍ∏∞ ÏúÑÌïú ChatPromptTemplateÏùÑ ÏÉùÏÑ±Ìï®. create_tool_calling_agent Ìï®ÏàòÎ•º ÏÇ¨Ïö©Ìï¥ Ïñ∏Ïñ¥ Î™®Îç∏, tools, promptÎ•º AgentÎ°ú Í≤∞Ìï©Ìï®. Í∑∏ Îã§Ïùå AgentExecutorÎ•º ÏÑ§Ï†ïÌïòÏó¨ Agent Ïã§ÌñâÍ≥º tool Ìò∏Ï∂úÏùÑ Í¥ÄÎ¶¨Ìï®. run_agent_with_tool ÎπÑÎèôÍ∏∞ Ìï®ÏàòÎäî Ï£ºÏñ¥ÏßÑ ÏøºÎ¶¨Î°ú AgentÎ•º Ìò∏Ï∂úÌïòÍ≥† Í≤∞Í≥ºÎ•º Ï∂úÎ†•ÌïòÎèÑÎ°ù Ï†ïÏùòÎê®. main ÎπÑÎèôÍ∏∞ Ìï®ÏàòÎäî Ïó¨Îü¨ ÏøºÎ¶¨Î•º ÎèôÏãúÏóê Ïã§ÌñâÌïòÎèÑÎ°ù Ï§ÄÎπÑÌï®. Ïù¥ ÏøºÎ¶¨Îì§ÏùÄ search_information toolÏùò ÌäπÏ†ï ÏùëÎãµÍ≥º Í∏∞Î≥∏ ÏùëÎãµÏùÑ Î™®Îëê ÌÖåÏä§Ìä∏ÌïòÎèÑÎ°ù ÏÑ§Í≥ÑÎê®. ÎßàÏßÄÎßâÏúºÎ°ú asyncio.run(main()) Ìò∏Ï∂úÏù¥ Î™®Îì† Agent ÏûëÏóÖÏùÑ Ïã§ÌñâÌï®. ÏΩîÎìúÎäî Agent ÏÑ§Ï†ï Î∞è Ïã§ÌñâÏùÑ ÏßÑÌñâÌïòÍ∏∞ Ï†Ñ ÏÑ±Í≥µÏ†ÅÏù∏ LLM Ï¥àÍ∏∞ÌôîÎ•º ÏúÑÌïú Ï≤¥ÌÅ¨Î•º Ìè¨Ìï®Ìï®.

# Ïã§Ïäµ ÏΩîÎìú ÏòàÏ†ú (CrewAI)

Ïù¥ ÏΩîÎìúÎäî CrewAI framework ÎÇ¥ÏóêÏÑú function calling(Tools)ÏùÑ Íµ¨ÌòÑÌïòÎäî Î∞©Î≤ïÏùò Ïã§Ïö©Ï†Å ÏòàÏ†úÎ•º Ï†úÍ≥µÌï®. Ï†ïÎ≥¥ Ï°∞Ìöå toolÏùÑ Í∞ñÏ∂ò AgentÍ∞Ä ÏÑ§Ï†ïÎêòÎäî Í∞ÑÎã®Ìïú ÏãúÎÇòÎ¶¨Ïò§Î•º Íµ¨ÏÑ±Ìï®. ÏòàÏ†úÎäî ÌäπÌûà Ïù¥ AgentÏôÄ toolÏùÑ ÏÇ¨Ïö©Ìï¥ ÏãúÎÆ¨Î†àÏù¥ÏÖòÎêú Ï£ºÏãù Í∞ÄÍ≤©ÏùÑ Í∞ÄÏ†∏Ïò§Îäî Í≤ÉÏùÑ Î≥¥Ïó¨Ï§å.

```python
# pip install crewai langchain-openai
import os
from crewai import Agent, Task, Crew
from crewai.tools import tool
import logging

# --- Best Practice: Configure Logging ---
# A basic logging setup helps in debugging and tracking the crew's execution.
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Set up your API Key ---
# For production, it's recommended to use a more secure method for key management
# like environment variables loaded at runtime or a secret manager.
#
# Set the environment variable for your chosen LLM provider (e.g., OPENAI_API_KEY)
# os.environ["OPENAI_API_KEY"] = "YOUR_API_KEY"
# os.environ["OPENAI_MODEL_NAME"] = "gpt-4o"

# --- 1. Refactored Tool: Returns Clean Data ---
# The tool now returns raw data (a float) or raises a standard Python error.
# This makes it more reusable and forces the agent to handle outcomes properly.
@tool("Stock Price Lookup Tool")
def get_stock_price(ticker: str) -> float:
    """
    Fetches the latest simulated stock price for a given stock ticker symbol.
    Returns the price as a float. Raises a ValueError if the ticker is not found.
    """
    logging.info(f"Tool Call: get_stock_price for ticker '{ticker}'")
    simulated_prices = {
        "AAPL": 178.15,
        "GOOGL": 1750.30,
        "MSFT": 425.50,
    }
    price = simulated_prices.get(ticker.upper())
    if price is not None:
        return price
    else:
        # Raising a specific error is better than returning a string.
        # The agent is equipped to handle exceptions and can decide on the next action.
        raise ValueError(f"Simulated price for ticker '{ticker.upper()}' not found.")

# --- 2. Define the Agent ---
# The agent definition remains the same, but it will now leverage the improved tool.
financial_analyst_agent = Agent(
    role='Senior Financial Analyst',
    goal='Analyze stock data using provided tools and report key prices.',
    backstory="You are an experienced financial analyst adept at using data sources to find stock information. You provide clear, direct answers.",
    verbose=True,
    tools=[get_stock_price],
    # Allowing delegation can be useful, but is not necessary for this simple task.
    allow_delegation=False,
)

# --- 3. Refined Task: Clearer Instructions and Error Handling ---
# The task description is more specific and guides the agent on how to react
# to both successful data retrieval and potential errors.
analyze_aapl_task = Task(
    description=(
        "What is the current simulated stock price for Apple (ticker: AAPL)? "
        "Use the 'Stock Price Lookup Tool' to find it. "
        "If the ticker is not found, you must report that you were unable to retrieve the price."
    ),
    expected_output=(
        "A single, clear sentence stating the simulated stock price for AAPL. "
        "For example: 'The simulated stock price for AAPL is $178.15.' "
        "If the price cannot be found, state that clearly."
    ),
    agent=financial_analyst_agent,
)

# --- 4. Formulate the Crew ---
# The crew orchestrates how the agent and task work together.
financial_crew = Crew(
    agents=[financial_analyst_agent],
    tasks=[analyze_aapl_task],
    verbose=True # Set to False for less detailed logs in production
)

# --- 5. Run the Crew within a Main Execution Block ---
# Using a __name__ == "__main__": block is a standard Python best practice.
def main():
    """Main function to run the crew."""
    # Check for API key before starting to avoid runtime errors.
    if not os.environ.get("OPENAI_API_KEY"):
        print("ERROR: The OPENAI_API_KEY environment variable is not set.")
        print("Please set it before running the script.")
        return

    print("\n## Starting the Financial Crew...")
    print("---------------------------------")

    # The kickoff method starts the execution.
    result = financial_crew.kickoff()
    print("\n---------------------------------")
    print("## Crew execution finished.")
    print("\nFinal Result:\n", result)

if __name__ == "__main__":
    main()
```

Ïù¥ ÏΩîÎìúÎäî Crew.ai ÎùºÏù¥Î∏åÎü¨Î¶¨Î•º ÏÇ¨Ïö©Ìï¥ Í∏àÏúµ Î∂ÑÏÑù ÏûëÏóÖÏùÑ ÏãúÎÆ¨Î†àÏù¥ÏÖòÌïòÎäî Í∞ÑÎã®Ìïú Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖòÏùÑ Î≥¥Ïó¨Ï§å. ÏÇ¨Ï†Ñ Ï†ïÏùòÎêú tickerÏóê ÎåÄÌïú Ï£ºÏãù Í∞ÄÍ≤© Ï°∞ÌöåÎ•º ÏãúÎÆ¨Î†àÏù¥ÏÖòÌïòÎäî Ïª§Ïä§ÌÖÄ toolÏù∏ get_stock_priceÎ•º Ï†ïÏùòÌï®. ToolÏùÄ Ïú†Ìö®Ìïú tickerÏóê ÎåÄÌï¥ Î∂ÄÎèôÏÜåÏàòÏ†ê Ïà´ÏûêÎ•º Î∞òÌôòÌïòÍ±∞ÎÇò Î¨¥Ìö®Ìïú tickerÏóê ÎåÄÌï¥ ValueErrorÎ•º Î∞úÏÉùÏãúÌÇ§ÎèÑÎ°ù ÏÑ§Í≥ÑÎê®. financial_analyst_agentÎùºÎäî Crew.ai AgentÎ•º Senior Financial Analyst Ïó≠Ìï†Î°ú ÏÉùÏÑ±Ìï®. Ïù¥ AgentÏóêÍ≤å ÏÉÅÌò∏ÏûëÏö©Ìï† get_stock_price toolÏùÑ Ï†úÍ≥µÌï®. TaskÏù∏ analyze_aapl_taskÎ•º Ï†ïÏùòÌïòÏó¨, Íµ¨Ï≤¥Ï†ÅÏúºÎ°ú toolÏùÑ ÏÇ¨Ïö©Ìï¥ AAPLÏùò ÏãúÎÆ¨Î†àÏù¥ÏÖòÎêú Ï£ºÏãù Í∞ÄÍ≤©ÏùÑ Ï∞æÎèÑÎ°ù AgentÏóê ÏßÄÏãúÌï®. Task ÏÑ§Î™ÖÏóêÎäî tool ÏÇ¨Ïö© Ïãú ÏÑ±Í≥µ Î∞è Ïã§Ìå® ÏºÄÏù¥Ïä§Î•º Î™®Îëê Ï≤òÎ¶¨ÌïòÎäî Î∞©Î≤ïÏóê ÎåÄÌïú Î™ÖÌôïÌïú ÏßÄÏπ®Ïù¥ Ìè¨Ìï®Îê®. financial_analyst_agentÏôÄ analyze_aapl_taskÎ°ú Íµ¨ÏÑ±Îêú CrewÎ•º Ï°∞Î¶ΩÌï®. Ïã§Ìñâ Ï§ë ÏÉÅÏÑ∏ Î°úÍπÖÏùÑ Ï†úÍ≥µÌïòÍ∏∞ ÏúÑÌï¥ AgentÏôÄ Crew Î™®ÎëêÏóê verbose ÏÑ§Ï†ïÏùÑ ÌôúÏÑ±ÌôîÌï®. Ïä§ÌÅ¨Î¶ΩÌä∏Ïùò main Î∂ÄÎ∂ÑÏùÄ ÌëúÏ§Ä if __name__ == "__main__": Î∏îÎ°ù ÎÇ¥ÏóêÏÑú kickoff() Î©îÏÑúÎìúÎ•º ÏÇ¨Ïö©Ìï¥ CrewÏùò ÏûëÏóÖÏùÑ Ïã§ÌñâÌï®. CrewÎ•º ÏãúÏûëÌïòÍ∏∞ Ï†Ñ AgentÍ∞Ä ÏûëÎèôÌïòÎäî Îç∞ ÌïÑÏöîÌïú OPENAI_API_KEY ÌôòÍ≤Ω Î≥ÄÏàòÍ∞Ä ÏÑ§Ï†ïÎêòÏñ¥ ÏûàÎäîÏßÄ ÌôïÏù∏Ìï®. Crew Ïã§Ìñâ Í≤∞Í≥ºÏù∏ taskÏùò Ï∂úÎ†•ÏùÑ ÏΩòÏÜîÏóê Ï∂úÎ†•Ìï®. ÏΩîÎìúÎäî CrewÏùò ÌñâÎèôÍ≥º tool Ìò∏Ï∂úÏùÑ Îçî Ïûò Ï∂îÏ†ÅÌïòÍ∏∞ ÏúÑÌïú Í∏∞Î≥∏ Î°úÍπÖ Íµ¨ÏÑ±ÎèÑ Ìè¨Ìï®Ìï®. API ÌÇ§ Í¥ÄÎ¶¨Î•º ÏúÑÌï¥ ÌôòÍ≤Ω Î≥ÄÏàòÎ•º ÏÇ¨Ïö©ÌïòÏßÄÎßå, ÌîÑÎ°úÎçïÏÖò ÌôòÍ≤ΩÏóêÏÑúÎäî Îçî ÏïàÏ†ÑÌïú Î∞©Î≤ïÏùÑ Í∂åÏû•ÌïúÎã§Í≥† Î™ÖÏãúÌï®. ÏöîÏïΩÌïòÎ©¥ ÌïµÏã¨ Î°úÏßÅÏùÄ Crew.aiÏóêÏÑú ÌòëÏóÖ ÏõåÌÅ¨ÌîåÎ°úÏö∞Î•º ÏÉùÏÑ±ÌïòÍ∏∞ ÏúÑÌï¥ tools, agents, tasksÎ•º Ï†ïÏùòÌïòÎäî Î∞©Î≤ïÏùÑ Î≥¥Ïó¨Ï§å.

# Ïã§Ïäµ ÏΩîÎìú (Google ADK)

# Google Agent Developer Kit (ADK)Îäî AgentÏùò Îä•Î†•Ïóê ÏßÅÏ†ë ÌÜµÌï©Ìï† Ïàò ÏûàÎäî ÎÑ§Ïù¥Ìã∞Î∏å ÌÜµÌï© tool ÎùºÏù¥Î∏åÎü¨Î¶¨Î•º Ìè¨Ìï®Ìï®.

# **Google search:** Ïù¥Îü¨Ìïú Ïª¥Ìè¨ÎÑåÌä∏Ïùò Ï£ºÏöî ÏòàÏãúÎäî Google Search toolÏûÑ. Ïù¥ toolÏùÄ Google Search ÏóîÏßÑÏóê ÎåÄÌïú ÏßÅÏ†ë Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ Ïó≠Ìï†ÏùÑ ÌïòÎ©∞, AgentÏóê Ïõπ Í≤ÄÏÉâÏùÑ ÏàòÌñâÌïòÍ≥† Ïô∏Î∂Ä Ï†ïÎ≥¥Î•º Í≤ÄÏÉâÌïòÎäî Í∏∞Îä•ÏùÑ Ï†úÍ≥µÌï®.

```python
from google.adk.agents import Agent
from google.adk.runners import Runner
from google.adk.sessions import InMemorySessionService
from google.adk.tools import google_search
from google.genai import types
import nest_asyncio
import asyncio

# Define variables required for Session setup and Agent execution
APP_NAME="Google Search_agent"
USER_ID="user1234"
SESSION_ID="1234"

# Define Agent with access to search tool
root_agent = ADKAgent(
  name="basic_search_agent",
  model="gemini-2.0-flash-exp",
  description="Agent to answer questions using Google Search.",
  instruction="I can answer your questions by searching the internet. Just ask me anything!",
  tools=[google_search] # Google Search is a pre-built tool to perform Google searches.
)

# Agent Interaction
async def call_agent(query):
  """
  Helper function to call the agent with a query.
  """
  # Session and Runner
  session_service = InMemorySessionService()
  session = await session_service.create_session(app_name=APP_NAME, user_id=USER_ID, session_id=SESSION_ID)
  runner = Runner(agent=root_agent, app_name=APP_NAME, session_service=session_service)

  content = types.Content(role='user', parts=[types.Part(text=query)])
  events = runner.run(user_id=USER_ID, session_id=SESSION_ID, new_message=content)

  for event in events:
      if event.is_final_response():
          final_response = event.content.parts[0].text
          print("Agent Response: ", final_response)

nest_asyncio.apply()
asyncio.run(call_agent("what's the latest ai news?"))
```

Ïù¥ ÏΩîÎìúÎäî PythonÏö© Google ADKÎ•º ÏÇ¨Ïö©Ìï¥ Í∏∞Î≥∏ AgentÎ•º ÏÉùÏÑ±ÌïòÍ≥† ÏÇ¨Ïö©ÌïòÎäî Î∞©Î≤ïÏùÑ Î≥¥Ïó¨Ï§å. AgentÎäî Google SearchÎ•º toolÎ°ú ÌôúÏö©ÌïòÏó¨ ÏßàÎ¨∏Ïóê ÎãµÎ≥ÄÌïòÎèÑÎ°ù ÏÑ§Í≥ÑÎê®. Î®ºÏ†Ä IPython, google.adk, google.genaiÏóêÏÑú ÌïÑÏöîÌïú ÎùºÏù¥Î∏åÎü¨Î¶¨Î•º importÌï®. Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Ïù¥Î¶Ñ, ÏÇ¨Ïö©Ïûê ID, ÏÑ∏ÏÖò IDÏóê ÎåÄÌïú ÏÉÅÏàòÎ•º Ï†ïÏùòÌï®. ÏÑ§Î™ÖÍ≥º ÏßÄÏπ®ÏúºÎ°ú Î™©Ï†ÅÏùÑ ÎÇòÌÉÄÎÇ¥Îäî "basic_search_agent"ÎùºÎäî Agent Ïù∏Ïä§ÌÑ¥Ïä§Î•º ÏÉùÏÑ±Ìï®. ADKÏóêÏÑú Ï†úÍ≥µÌïòÎäî ÏÇ¨Ï†Ñ Íµ¨Ï∂ï toolÏù∏ Google Search toolÏùÑ ÏÇ¨Ïö©ÌïòÎèÑÎ°ù Íµ¨ÏÑ±Îê®. AgentÏóê ÎåÄÌïú ÏÑ∏ÏÖòÏùÑ Í¥ÄÎ¶¨ÌïòÍ∏∞ ÏúÑÌï¥ InMemorySessionService(Chapter 8 Ï∞∏Ï°∞)Î•º Ï¥àÍ∏∞ÌôîÌï®. ÏßÄÏ†ïÎêú Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò, ÏÇ¨Ïö©Ïûê, ÏÑ∏ÏÖò IDÏóê ÎåÄÌï¥ ÏÉà ÏÑ∏ÏÖòÏùÑ ÏÉùÏÑ±Ìï®. ÏÉùÏÑ±Îêú AgentÎ•º ÏÑ∏ÏÖò ÏÑúÎπÑÏä§ÏôÄ Ïó∞Í≤∞ÌïòÎäî RunnerÎ•º Ïù∏Ïä§ÌÑ¥Ïä§ÌôîÌï®. Ïù¥ runnerÎäî ÏÑ∏ÏÖò ÎÇ¥ÏóêÏÑú AgentÏùò ÏÉÅÌò∏ÏûëÏö© Ïã§ÌñâÏùÑ Îã¥ÎãπÌï®. AgentÏóê ÏøºÎ¶¨Î•º Î≥¥ÎÇ¥Í≥† ÏùëÎãµÏùÑ Ï≤òÎ¶¨ÌïòÎäî Í≥ºÏ†ïÏùÑ Îã®ÏàúÌôîÌïòÍ∏∞ ÏúÑÌï¥ call_agent helper Ìï®ÏàòÎ•º Ï†ïÏùòÌï®. call_agent ÎÇ¥Î∂ÄÏóêÏÑú ÏÇ¨Ïö©ÏûêÏùò ÏøºÎ¶¨Îäî 'user' Ïó≠Ìï†ÏùÑ Í∞ÄÏßÑ types.Content Í∞ùÏ≤¥Î°ú Ìè¨Îß∑ÌåÖÎê®. runner.run Î©îÏÑúÎìúÍ∞Ä ÏÇ¨Ïö©Ïûê ID, ÏÑ∏ÏÖò ID, ÏÉà Î©îÏãúÏßÄ contentÏôÄ Ìï®Íªò Ìò∏Ï∂úÎê®. runner.run Î©îÏÑúÎìúÎäî AgentÏùò ÌñâÎèôÍ≥º ÏùëÎãµÏùÑ ÎÇòÌÉÄÎÇ¥Îäî Ïù¥Î≤§Ìä∏ Î¶¨Ïä§Ìä∏Î•º Î∞òÌôòÌï®. ÏΩîÎìúÎäî Ïù¥Îü¨Ìïú Ïù¥Î≤§Ìä∏Îì§ÏùÑ Î∞òÎ≥µÌïòÎ©∞ ÏµúÏ¢Ö ÏùëÎãµÏùÑ Ï∞æÏùå. Ïù¥Î≤§Ìä∏Í∞Ä ÏµúÏ¢Ö ÏùëÎãµÏúºÎ°ú ÏãùÎ≥ÑÎêòÎ©¥ Ìï¥Îãπ ÏùëÎãµÏùò ÌÖçÏä§Ìä∏ contentÎ•º Ï∂îÏ∂úÌï®. Ï∂îÏ∂úÎêú Agent ÏùëÎãµÏùÑ ÏΩòÏÜîÏóê Ï∂úÎ†•Ìï®. ÎßàÏßÄÎßâÏúºÎ°ú call_agent Ìï®ÏàòÎ•º "what's the latest ai news?" ÏøºÎ¶¨Î°ú Ìò∏Ï∂úÌïòÏó¨ AgentÎ•º Ïã§Ï†úÎ°ú Î≥¥Ïó¨Ï§å.

**Code execution:** Google ADKÎäî ÎèôÏ†Å ÏΩîÎìú Ïã§ÌñâÏùÑ ÏúÑÌïú ÌôòÍ≤ΩÏùÑ Ìè¨Ìï®Ìïú ÌäπÌôî ÏûëÏóÖÏö© ÌÜµÌï© Ïª¥Ìè¨ÎÑåÌä∏Î•º Ï†úÍ≥µÌï®. built_in_code_execution toolÏùÄ AgentÏóêÍ≤å ÏÉåÎìúÎ∞ïÏä§ Python Ïù∏ÌÑ∞ÌîÑÎ¶¨ÌÑ∞Î•º Ï†úÍ≥µÌï®. Ïù¥Î•º ÌÜµÌï¥ Î™®Îç∏Ïù¥ ÏΩîÎìúÎ•º ÏûëÏÑ±ÌïòÍ≥† Ïã§ÌñâÌïòÏó¨ Í≥ÑÏÇ∞ ÏûëÏóÖÏùÑ ÏàòÌñâÌïòÍ≥†, Îç∞Ïù¥ÌÑ∞ Íµ¨Ï°∞Î•º Ï°∞ÏûëÌïòÎ©∞, Ï†àÏ∞®Ï†Å Ïä§ÌÅ¨Î¶ΩÌä∏Î•º Ïã§ÌñâÌï† Ïàò ÏûàÏùå. Ïù¥Îü¨Ìïú Í∏∞Îä•ÏùÄ ÌôïÎ•†Ï†Å Ïñ∏Ïñ¥ ÏÉùÏÑ± Î≤îÏúÑÎ•º Î≤óÏñ¥ÎÇòÎäî Í≤∞Ï†ïÎ°†Ï†Å Î°úÏßÅÍ≥º Ï†ïÎ∞ÄÌïú Í≥ÑÏÇ∞ÏùÑ ÌïÑÏöîÎ°ú ÌïòÎäî Î¨∏Ï†úÎ•º Ìï¥Í≤∞ÌïòÎäî Îç∞ Ï§ëÏöîÌï®.

```python
import os, getpass
import asyncio
import nest_asyncio
from typing import List
from dotenv import load_dotenv
import logging
from google.adk.agents import Agent as ADKAgent, LlmAgent
from google.adk.runners import Runner
from google.adk.sessions import InMemorySessionService
from google.adk.tools import google_search
from google.adk.code_executors import BuiltInCodeExecutor
from google.genai import types

# Define variables required for Session setup and Agent execution
APP_NAME="calculator"
USER_ID="user1234"
SESSION_ID="session_code_exec_async"

# Agent Definition
code_agent = LlmAgent(
    name="calculator_agent",
    model="gemini-2.0-flash",
    code_executor=BuiltInCodeExecutor(),
    instruction="""You are a calculator agent.
    When given a mathematical expression, write and execute Python code to calculate the result.
    Return only the final numerical result as plain text, without markdown or code blocks.
    """,
    description="Executes Python code to perform calculations.",
)

# Agent Interaction (Async)
async def call_agent_async(query):
    # Session and Runner
    session_service = InMemorySessionService()
    session = await session_service.create_session(app_name=APP_NAME, user_id=USER_ID, session_id=SESSION_ID)
    runner = Runner(agent=code_agent, app_name=APP_NAME, session_service=session_service)
    content = types.Content(role='user', parts=[types.Part(text=query)])
    print(f"\n--- Running Query: {query} ---")
    final_response_text = "No final text response captured."
    try:
        # Use run_async
        async for event in runner.run_async(user_id=USER_ID, session_id=SESSION_ID, new_message=content):
            print(f"Event ID: {event.id}, Author: {event.author}")
            # --- Check for specific parts FIRST ---
            # has_specific_part = False
            if event.content and event.content.parts and event.is_final_response():
                for part in event.content.parts: # Iterate through all parts
                    if part.executable_code:
                        # Access the actual code string via .code
                        print(f"  Debug: Agent generated code:\n```python\n{part.executable_code.code}\n```")
                        has_specific_part = True
                    elif part.code_execution_result:
                        # Access outcome and output correctly
                        print(f"  Debug: Code Execution Result: {part.code_execution_result.outcome} - Output:\n{part.code_execution_result.output}")
                        has_specific_part = True
                    # Also print any text parts found in any event for debugging
                    elif part.text and not part.text.isspace():
                        print(f"  Text: '{part.text.strip()}'")
                        # Do not set has_specific_part=True here, as we want the final response logic below
                # --- Check for final response AFTER specific parts ---
                text_parts = [part.text for part in event.content.parts if part.text]
                final_result = "".join(text_parts)
                print(f"==> Final Agent Response: {final_result}")
    except Exception as e:
        print(f"ERROR during agent run: {e}")
    print("-" * 30)

# Main async function to run the examples
async def main():
    await call_agent_async("Calculate the value of (5 + 7) * 3")
    await call_agent_async("What is 10 factorial?")

# Execute the main async function
try:
    nest_asyncio.apply()
    asyncio.run(main())
except RuntimeError as e:
    # Handle specific error when running asyncio.run in an already running loop (like Jupyter/Colab)
    if "cannot be called from a running event loop" in str(e):
        print("\nRunning in an existing event loop (like Colab/Jupyter).")
        print("Please run `await main()` in a notebook cell instead.")
        # If in an interactive environment like a notebook, you might need to run:
        # await main()
    else:
        raise e # Re-raise other runtime errors
```

Ïù¥ Ïä§ÌÅ¨Î¶ΩÌä∏Îäî GoogleÏùò Agent Development Kit (ADK)Î•º ÏÇ¨Ïö©Ìï¥ Python ÏΩîÎìúÎ•º ÏûëÏÑ±ÌïòÍ≥† Ïã§ÌñâÌïòÏó¨ ÏàòÌïô Î¨∏Ï†úÎ•º Ìï¥Í≤∞ÌïòÎäî AgentÎ•º ÏÉùÏÑ±Ìï®. Í≥ÑÏÇ∞Í∏∞Î°ú ÏûëÎèôÌïòÎèÑÎ°ù Íµ¨Ï≤¥Ï†ÅÏúºÎ°ú ÏßÄÏãúÎêú LlmAgentÎ•º Ï†ïÏùòÌïòÎ©∞, built_in_code_execution toolÏùÑ Í∞ñÏ∂îÍ≥† ÏûàÏùå. Ï£ºÏöî Î°úÏßÅÏùÄ ÏÇ¨Ïö©Ïûê ÏøºÎ¶¨Î•º AgentÏùò runnerÏóê Ï†ÑÏÜ°ÌïòÍ≥† Í≤∞Í≥º Ïù¥Î≤§Ìä∏Î•º Ï≤òÎ¶¨ÌïòÎäî call_agent_async Ìï®ÏàòÏóê ÏûàÏùå. Ïù¥ Ìï®Ïàò ÎÇ¥Î∂ÄÏóêÏÑú ÎπÑÎèôÍ∏∞ Î£®ÌîÑÍ∞Ä Ïù¥Î≤§Ìä∏Î•º Î∞òÎ≥µÌïòÎ©∞, ÏÉùÏÑ±Îêú Python ÏΩîÎìúÏôÄ Í∑∏ Ïã§Ìñâ Í≤∞Í≥ºÎ•º ÎîîÎ≤ÑÍπÖÏùÑ ÏúÑÌï¥ Ï∂úÎ†•Ìï®. ÏΩîÎìúÎäî Ïù¥Îü¨Ìïú Ï§ëÍ∞Ñ Îã®Í≥ÑÏôÄ ÏàòÏπò ÎãµÎ≥ÄÏùÑ Ìè¨Ìï®ÌïòÎäî ÏµúÏ¢Ö Ïù¥Î≤§Ìä∏Î•º Ïã†Ï§ëÌûà Íµ¨Î∂ÑÌï®. ÎßàÏßÄÎßâÏúºÎ°ú main Ìï®ÏàòÍ∞Ä Îëê Í∞úÏùò ÏÑúÎ°ú Îã§Î•∏ ÏàòÌïô ÌëúÌòÑÏãùÏúºÎ°ú AgentÎ•º Ïã§ÌñâÌïòÏó¨ Í≥ÑÏÇ∞ ÏàòÌñâ Îä•Î†•ÏùÑ Î≥¥Ïó¨Ï§å.

**Enterprise search:** Ïù¥ ÏΩîÎìúÎäî PythonÏóêÏÑú google.adk ÎùºÏù¥Î∏åÎü¨Î¶¨Î•º ÏÇ¨Ïö©ÌïòÎäî Google ADK Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖòÏùÑ Ï†ïÏùòÌï®. ÌäπÌûà ÏßÄÏ†ïÎêú Vertex AI Search datastoreÎ•º Í≤ÄÏÉâÌïòÏó¨ ÏßàÎ¨∏Ïóê ÎãµÎ≥ÄÌïòÎèÑÎ°ù ÏÑ§Í≥ÑÎêú VSearchAgentÎ•º ÏÇ¨Ïö©Ìï®. ÏΩîÎìúÎäî "q2_strategy_vsearch_agent"ÎùºÎäî VSearchAgentÎ•º Ï¥àÍ∏∞ÌôîÌïòÎ©∞, ÏÑ§Î™Ö, ÏÇ¨Ïö©Ìï† Î™®Îç∏("gemini-2.0-flash-exp"), Vertex AI Search datastoreÏùò IDÎ•º Ï†úÍ≥µÌï®. DATASTORE_IDÎäî ÌôòÍ≤Ω Î≥ÄÏàòÎ°ú ÏÑ§Ï†ïÎêòÏñ¥Ïïº Ìï®. Í∑∏ Îã§Ïùå ÎåÄÌôî Í∏∞Î°ùÏùÑ Í¥ÄÎ¶¨ÌïòÍ∏∞ ÏúÑÌï¥ InMemorySessionServiceÎ•º ÏÇ¨Ïö©ÌïòÏó¨ AgentÏóê ÎåÄÌïú RunnerÎ•º ÏÑ§Ï†ïÌï®. call_vsearch_agent_asyncÎùºÎäî ÎπÑÎèôÍ∏∞ Ìï®ÏàòÍ∞Ä AgentÏôÄ ÏÉÅÌò∏ÏûëÏö©ÌïòÎèÑÎ°ù Ï†ïÏùòÎê®. Ïù¥ Ìï®ÏàòÎäî ÏøºÎ¶¨Î•º Î∞õÏïÑ Î©îÏãúÏßÄ content Í∞ùÏ≤¥Î•º Íµ¨ÏÑ±ÌïòÍ≥† runnerÏùò run_async Î©îÏÑúÎìúÎ•º Ìò∏Ï∂úÌïòÏó¨ ÏøºÎ¶¨Î•º AgentÏóê Ï†ÑÏÜ°Ìï®. Í∑∏ Îã§Ïùå Ìï®ÏàòÎäî AgentÏùò ÏùëÎãµÏù¥ ÎèÑÏ∞©ÌïòÎäî ÎåÄÎ°ú ÏΩòÏÜîÏóê Ïä§Ìä∏Î¶¨Î∞çÌï®. ÎòêÌïú datastoreÏóêÏÑú ÎÇòÏò® ÏÜåÏä§ Ï∂úÏ≤òÎ•º Ìè¨Ìï®Ìïú ÏµúÏ¢Ö ÏùëÎãµÏóê ÎåÄÌïú Ï†ïÎ≥¥Î•º Ï∂úÎ†•Ìï®. ÏûòÎ™ªÎêú datastore IDÎÇò ÎàÑÎùΩÎêú Í∂åÌïú Í∞ôÏùÄ Ïû†Ïû¨Ï†Å Ïù¥ÏäàÏóê ÎåÄÌï¥ Ï†ïÎ≥¥ÏÑ± Î©îÏãúÏßÄÎ•º Ï†úÍ≥µÌïòÎäî Ïò§Î•ò Ï≤òÎ¶¨Í∞Ä Ìè¨Ìï®Îê®. ÏòàÏãú ÏøºÎ¶¨Î°ú AgentÎ•º Ìò∏Ï∂úÌïòÎäî Î∞©Î≤ïÏùÑ Î≥¥Ïó¨Ï£ºÍ∏∞ ÏúÑÌï¥ run_vsearch_exampleÏù¥ÎùºÎäî Îã§Î•∏ ÎπÑÎèôÍ∏∞ Ìï®ÏàòÍ∞Ä Ï†úÍ≥µÎê®. main Ïã§Ìñâ Î∏îÎ°ùÏùÄ DATASTORE_IDÍ∞Ä ÏÑ§Ï†ïÎêòÏóàÎäîÏßÄ ÌôïÏù∏Ìïú ÌõÑ asyncio.runÏùÑ ÏÇ¨Ïö©Ìï¥ ÏòàÏãúÎ•º Ïã§ÌñâÌï®. Jupyter notebook Í∞ôÏù¥ Ïù¥ÎØ∏ Ïã§Ìñâ Ï§ëÏù∏ Ïù¥Î≤§Ìä∏ Î£®ÌîÑÍ∞Ä ÏûàÎäî ÌôòÍ≤ΩÏóêÏÑú ÏΩîÎìúÍ∞Ä Ïã§ÌñâÎêòÎäî Í≤ΩÏö∞Î•º Ï≤òÎ¶¨ÌïòÍ∏∞ ÏúÑÌïú Ï≤¥ÌÅ¨Î•º Ìè¨Ìï®Ìï®.

```python
import asyncio
from google.genai import types
from google.adk import agents
from google.adk.runners import Runner
from google.adk.sessions import InMemorySessionService
import os

# --- Configuration ---
# Ensure you have set your GOOGLE_API_KEY and DATASTORE_ID environment variables
# For example:
# os.environ["GOOGLE_API_KEY"] = "YOUR_API_KEY"
# os.environ["DATASTORE_ID"] = "YOUR_DATASTORE_ID"

DATASTORE_ID = os.environ.get("DATASTORE_ID")

# --- Application Constants ---
APP_NAME = "vsearch_app"
USER_ID = "user_123"  # Example User ID
SESSION_ID = "session_456" # Example Session ID

# --- Agent Definition (Updated with the newer model from the guide) ---
vsearch_agent = agents.VSearchAgent(
    name="q2_strategy_vsearch_agent",
    description="Answers questions about Q2 strategy documents using Vertex AI Search.",
    model="gemini-2.0-flash-exp", # Updated model based on the guide's examples
    datastore_id=DATASTORE_ID,
    model_parameters={"temperature": 0.0}
)

# --- Runner and Session Initialization ---
runner = Runner(
    agent=vsearch_agent,
    app_name=APP_NAME,
    session_service=InMemorySessionService(),
)

# --- Agent Invocation Logic ---
async def call_vsearch_agent_async(query: str):
    """Initializes a session and streams the agent's response."""
    print(f"User: {query}")
    print("Agent: ", end="", flush=True)
    try:
        # Construct the message content correctly
        content = types.Content(role='user', parts=[types.Part(text=query)])
        # Process events as they arrive from the asynchronous runner
        async for event in runner.run_async(
            user_id=USER_ID,
            session_id=SESSION_ID,
            new_message=content
        ):
            # For token-by-token streaming of the response text
            if hasattr(event, 'content_part_delta') and event.content_part_delta:
                print(event.content_part_delta.text, end="", flush=True)
            # Process the final response and its associated metadata
            if event.is_final_response():
                print() # Newline after the streaming response
                if event.grounding_metadata:
                    print(f"  (Source Attributions: {len(event.grounding_metadata.grounding_attributions)} sources found)")
                else:
                    print("  (No grounding metadata found)")
                print("-" * 30)
    except Exception as e:
        print(f"\nAn error occurred: {e}")
        print("Please ensure your datastore ID is correct and that the service account has the necessary permissions.")
        print("-" * 30)

# --- Run Example ---
async def run_vsearch_example():
    # Replace with a question relevant to YOUR datastore content
    await call_vsearch_agent_async("Summarize the main points about the Q2 strategy document.")
    await call_vsearch_agent_async("What safety procedures are mentioned for lab X?")

# --- Execution ---
if __name__ == "__main__":
    if not DATASTORE_ID:
        print("Error: DATASTORE_ID environment variable is not set.")
    else:
        try:
            asyncio.run(run_vsearch_example())
        except RuntimeError as e:
            # This handles cases where asyncio.run is called in an environment
            # that already has a running event loop (like a Jupyter notebook).
            if "cannot be called from a running event loop" in str(e):
                print("Skipping execution in a running event loop. Please run this script directly.")
            else:
                raise e
```

Ï†ÑÎ∞òÏ†ÅÏúºÎ°ú Ïù¥ ÏΩîÎìúÎäî Vertex AI SearchÎ•º ÌôúÏö©ÌïòÏó¨ datastoreÏóê Ï†ÄÏû•Îêú Ï†ïÎ≥¥Î•º Í∏∞Î∞òÏúºÎ°ú ÏßàÎ¨∏Ïóê ÎãµÎ≥ÄÌïòÎäî ÎåÄÌôîÌòï AI Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖòÏùÑ Íµ¨Ï∂ïÌïòÍ∏∞ ÏúÑÌïú Í∏∞Î≥∏ frameworkÎ•º Ï†úÍ≥µÌï®. AgentÎ•º Ï†ïÏùòÌïòÍ≥†, runnerÎ•º ÏÑ§Ï†ïÌïòÎ©∞, ÏùëÎãµÏùÑ Ïä§Ìä∏Î¶¨Î∞çÌïòÎ©¥ÏÑú ÎπÑÎèôÍ∏∞Ï†ÅÏúºÎ°ú AgentÏôÄ ÏÉÅÌò∏ÏûëÏö©ÌïòÎäî Î∞©Î≤ïÏùÑ Î≥¥Ïó¨Ï§å. ÌäπÏ†ï datastoreÏóêÏÑú Ï†ïÎ≥¥Î•º Í≤ÄÏÉâÌïòÍ≥† Ï¢ÖÌï©ÌïòÏó¨ ÏÇ¨Ïö©Ïûê ÏøºÎ¶¨Ïóê ÎãµÎ≥ÄÌïòÎäî Îç∞ Ï§ëÏ†êÏùÑ Îë†.

**Vertex Extensions:** Vertex AI extensionÏùÄ Î™®Îç∏Ïù¥ Ïô∏Î∂Ä APIÏôÄ Ïó∞Í≤∞ÌïòÏó¨ Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨ Î∞è action Ïã§ÌñâÏùÑ Í∞ÄÎä•ÌïòÍ≤å ÌïòÎäî Íµ¨Ï°∞ÌôîÎêú API wrapperÏûÑ. ExtensionÏùÄ ÏóîÌÑ∞ÌîÑÎùºÏù¥Ï¶àÍ∏â Î≥¥Ïïà, Îç∞Ïù¥ÌÑ∞ ÌîÑÎùºÏù¥Î≤ÑÏãú Î∞è ÏÑ±Îä• Î≥¥Ïû•ÏùÑ Ï†úÍ≥µÌï®. ÏΩîÎìú ÏÉùÏÑ± Î∞è Ïã§Ìñâ, ÏõπÏÇ¨Ïù¥Ìä∏ ÏøºÎ¶¨, ÎπÑÍ≥µÍ∞ú datastoreÏùò Ï†ïÎ≥¥ Î∂ÑÏÑù Í∞ôÏùÄ ÏûëÏóÖÏóê ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏùå. GoogleÏùÄ Code Interpreter Î∞è Vertex AI Search Í∞ôÏùÄ ÏùºÎ∞òÏ†ÅÏù∏ ÏÇ¨Ïö© ÏÇ¨Î°ÄÏóê ÎåÄÌïú ÏÇ¨Ï†Ñ Íµ¨Ï∂ï extensionÏùÑ Ï†úÍ≥µÌïòÎ©∞, Ïª§Ïä§ÌÖÄ extensionÏùÑ ÏÉùÏÑ±Ìï† Ïàò ÏûàÎäî ÏòµÏÖòÎèÑ ÏûàÏùå. ExtensionÏùò Ï£ºÏöî Ïù¥Ï†êÏùÄ Í∞ïÎ†•Ìïú ÏóîÌÑ∞ÌîÑÎùºÏù¥Ï¶à Ï†úÏñ¥ÏôÄ Îã§Î•∏ Google Ï†úÌíàÍ≥ºÏùò ÏõêÌôúÌïú ÌÜµÌï©ÏùÑ Ìè¨Ìï®Ìï®. ExtensionÍ≥º function callingÏùò Ï£ºÏöî Ï∞®Ïù¥Ï†êÏùÄ Ïã§Ìñâ Î∞©ÏãùÏóê ÏûàÏùå: Vertex AIÍ∞Ä extensionÏùÑ ÏûêÎèôÏúºÎ°ú Ïã§ÌñâÌïòÎäî Î∞òÎ©¥, function callÏùÄ ÏÇ¨Ïö©ÏûêÎÇò ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Í∞Ä ÏàòÎèôÏúºÎ°ú Ïã§ÌñâÌï¥Ïïº Ìï®.

# ÌïúÎààÏóê Î≥¥Í∏∞

**What:** LLMÏùÄ Í∞ïÎ†•Ìïú ÌÖçÏä§Ìä∏ ÏÉùÏÑ±Í∏∞Ïù¥ÏßÄÎßå, Í∑ºÎ≥∏Ï†ÅÏúºÎ°ú Ïô∏Î∂Ä ÏÑ∏Í≥ÑÏôÄ Îã®Ï†àÎêòÏñ¥ ÏûàÏùå. Í∑∏Îì§Ïùò ÏßÄÏãùÏùÄ Ï†ïÏ†ÅÏù¥Î©∞ ÌõàÎ†® Îç∞Ïù¥ÌÑ∞Ïóê Ï†úÌïúÎêòÍ≥†, ÌñâÎèôÏùÑ ÏàòÌñâÌïòÍ±∞ÎÇò Ïã§ÏãúÍ∞Ñ Ï†ïÎ≥¥Î•º Í≤ÄÏÉâÌïòÎäî Îä•Î†•Ïù¥ ÏóÜÏùå. Ïù¥Îü¨Ìïú Î≥∏ÏßàÏ†Å Ï†úÏïΩÏùÄ Ïô∏Î∂Ä API, Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÎòêÎäî ÏÑúÎπÑÏä§ÏôÄÏùò ÏÉÅÌò∏ÏûëÏö©Ïù¥ ÌïÑÏöîÌïú ÏûëÏóÖÏùÑ ÏôÑÎ£åÌïòÏßÄ Î™ªÌïòÍ≤å Ìï®. Ïù¥Îü¨Ìïú Ïô∏Î∂Ä ÏãúÏä§ÌÖúÏúºÎ°úÏùò Îã§Î¶¨ ÏóÜÏù¥Îäî Ïã§Ï†ú Î¨∏Ï†ú Ìï¥Í≤∞ÏùÑ ÏúÑÌïú Ïú†Ïö©ÏÑ±Ïù¥ Ïã¨Í∞ÅÌïòÍ≤å Ï†úÌïúÎê®.

**Why:** Tool Use patternÏùÄ function callingÏùÑ ÌÜµÌï¥ Ï¢ÖÏ¢Ö Íµ¨ÌòÑÎêòÎ©∞, Ïù¥ Î¨∏Ï†úÏóê ÎåÄÌïú ÌëúÏ§ÄÌôîÎêú ÏÜîÎ£®ÏÖòÏùÑ Ï†úÍ≥µÌï®. ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Ïô∏Î∂Ä Ìï®Ïàò ÎòêÎäî "tools"Î•º LLMÏù¥ Ïù¥Ìï¥Ìï† Ïàò ÏûàÎäî Î∞©ÏãùÏúºÎ°ú ÏÑ§Î™ÖÌïòÎäî Î∞©ÏãùÏúºÎ°ú ÏûëÎèôÌï®. ÏÇ¨Ïö©Ïûê ÏöîÏ≤≠ÏùÑ Í∏∞Î∞òÏúºÎ°ú agentic LLMÏùÄ toolÏù¥ ÌïÑÏöîÌïúÏßÄ Í≤∞Ï†ïÌïòÍ≥† Ìò∏Ï∂úÌï† Ìï®ÏàòÏôÄ Ïù∏ÏûêÎ•º Î™ÖÏãúÌïòÎäî Íµ¨Ï°∞ÌôîÎêú Îç∞Ïù¥ÌÑ∞ Í∞ùÏ≤¥(Ïòà: JSON)Î•º ÏÉùÏÑ±Ìï† Ïàò ÏûàÏùå. Orchestration layerÍ∞Ä Ïù¥ function callÏùÑ Ïã§ÌñâÌïòÍ≥† Í≤∞Í≥ºÎ•º Í≤ÄÏÉâÌïòÏó¨ LLMÏóê ÌîºÎìúÎ∞±Ìï®. Ïù¥Î•º ÌÜµÌï¥ LLMÏù¥ ÏµúÏã† Ïô∏Î∂Ä Ï†ïÎ≥¥ÎÇò ÌñâÎèôÏùò Í≤∞Í≥ºÎ•º ÏµúÏ¢Ö ÏùëÎãµÏóê ÌÜµÌï©Ìï† Ïàò ÏûàÏñ¥ Ìö®Í≥ºÏ†ÅÏúºÎ°ú ÌñâÎèôÌï† Ïàò ÏûàÎäî Îä•Î†•ÏùÑ Î∂ÄÏó¨Ìï®.

**Rule of thumb:** AgentÍ∞Ä LLMÏùò ÎÇ¥Î∂Ä ÏßÄÏãùÏùÑ Î≤óÏñ¥ÎÇò Ïô∏Î∂Ä ÏÑ∏Í≥ÑÏôÄ ÏÉÅÌò∏ÏûëÏö©Ìï¥Ïïº Ìï† ÎïåÎßàÎã§ Tool Use patternÏùÑ ÏÇ¨Ïö©Ìï®. Ïù¥Îäî Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞(Ïòà: ÎÇ†Ïî®, Ï£ºÍ∞Ä ÌôïÏù∏), ÎπÑÍ≥µÍ∞ú ÎòêÎäî ÎèÖÏ†ê Ï†ïÎ≥¥ Ï†ëÍ∑º(Ïòà: ÌöåÏÇ¨ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏøºÎ¶¨), Ï†ïÎ∞ÄÌïú Í≥ÑÏÇ∞ ÏàòÌñâ, ÏΩîÎìú Ïã§Ìñâ, ÎòêÎäî Îã§Î•∏ ÏãúÏä§ÌÖúÏóêÏÑú ÌñâÎèô Ìä∏Î¶¨Í±∞(Ïòà: Ïù¥Î©îÏùº Ï†ÑÏÜ°, Ïä§ÎßàÌä∏ Ïû•Ïπò Ï†úÏñ¥)Í∞Ä ÌïÑÏöîÌïú ÏûëÏóÖÏóê ÌïÑÏàòÏ†ÅÏûÑ.

**Visual summary:**

![Tool Integration Flow](./images/chapter5/diagram-2.png)

Fig.2: Tool use design pattern

# ÌïµÏã¨ ÏöîÏ†ê

* Tool Use (Function Calling)Îäî AgentÍ∞Ä Ïô∏Î∂Ä ÏãúÏä§ÌÖúÍ≥º ÏÉÅÌò∏ÏûëÏö©ÌïòÍ≥† ÎèôÏ†Å Ï†ïÎ≥¥Ïóê Ï†ëÍ∑ºÌï† Ïàò ÏûàÍ≤å Ìï®.
* LLMÏù¥ Ïù¥Ìï¥Ìï† Ïàò ÏûàÎäî Î™ÖÌôïÌïú ÏÑ§Î™ÖÍ≥º ÌååÎùºÎØ∏ÌÑ∞Î°ú toolÏùÑ Ï†ïÏùòÌïòÎäî Í≤ÉÏùÑ Ìè¨Ìï®Ìï®.
* LLMÏù¥ tool ÏÇ¨Ïö© ÏãúÍ∏∞Î•º Í≤∞Ï†ïÌïòÍ≥† Íµ¨Ï°∞ÌôîÎêú function callÏùÑ ÏÉùÏÑ±Ìï®.
* Agentic frameworkÍ∞Ä Ïã§Ï†ú tool callÏùÑ Ïã§ÌñâÌïòÍ≥† Í≤∞Í≥ºÎ•º LLMÏóê Î∞òÌôòÌï®.
* Tool UseÎäî Ïã§Ï†ú ÌñâÎèôÏùÑ ÏàòÌñâÌïòÍ≥† ÏµúÏã† Ï†ïÎ≥¥Î•º Ï†úÍ≥µÌï† Ïàò ÏûàÎäî Agent Íµ¨Ï∂ïÏóê ÌïÑÏàòÏ†ÅÏûÑ.
* LangChainÏùÄ @tool decoratorÎ•º ÏÇ¨Ïö©Ìïú tool Ï†ïÏùòÎ•º Îã®ÏàúÌôîÌïòÍ≥† tool ÏÇ¨Ïö© Agent Íµ¨Ï∂ïÏùÑ ÏúÑÌïú create_tool_calling_agent Î∞è AgentExecutorÎ•º Ï†úÍ≥µÌï®.
* Google ADKÎäî Google Search, Code Execution, Vertex AI Search Tool Í∞ôÏùÄ Îß§Ïö∞ Ïú†Ïö©Ìïú ÏÇ¨Ï†Ñ Íµ¨Ï∂ï toolÎì§ÏùÑ Îã§Ïàò Î≥¥Ïú†Ìï®.

# Í≤∞Î°†

Tool Use patternÏùÄ ÎåÄÌòï Ïñ∏Ïñ¥ Î™®Îç∏Ïùò Í∏∞Îä•Ï†Å Î≤îÏúÑÎ•º Í≥†Ïú†Ìïú ÌÖçÏä§Ìä∏ ÏÉùÏÑ± Îä•Î†•ÏùÑ ÎÑòÏñ¥ ÌôïÏû•ÌïòÍ∏∞ ÏúÑÌïú Ï§ëÏöîÌïú ÏïÑÌÇ§ÌÖçÏ≤ò ÏõêÏπôÏûÑ. Î™®Îç∏Ïóê Ïô∏Î∂Ä ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ Î∞è Îç∞Ïù¥ÌÑ∞ ÏÜåÏä§ÏôÄ Ïù∏ÌÑ∞ÌéòÏù¥Ïä§Ìï† Ïàò ÏûàÎäî Îä•Î†•ÏùÑ Í∞ñÏ∂îÍ≤å Ìï®ÏúºÎ°úÏç®, Ïù¥ Ìå®Îü¨Îã§ÏûÑÏùÄ AgentÍ∞Ä ÌñâÎèôÏùÑ ÏàòÌñâÌïòÍ≥†, Í≥ÑÏÇ∞ÏùÑ Ïã§ÌñâÌïòÎ©∞, Îã§Î•∏ ÏãúÏä§ÌÖúÏóêÏÑú Ï†ïÎ≥¥Î•º Í≤ÄÏÉâÌï† Ïàò ÏûàÍ≤å Ìï®. Ïù¥ ÌîÑÎ°úÏÑ∏Ïä§Îäî Î™®Îç∏Ïù¥ ÏÇ¨Ïö©Ïûê ÏøºÎ¶¨Î•º Ï∂©Ï°±ÌïòÍ∏∞ ÏúÑÌï¥ ÌïÑÏöîÌïòÎã§Í≥† ÌåêÎã®Ìï† Îïå Ïô∏Î∂Ä toolÏùÑ Ìò∏Ï∂úÌïòÎäî Íµ¨Ï°∞ÌôîÎêú ÏöîÏ≤≠ÏùÑ ÏÉùÏÑ±ÌïòÎäî Í≤ÉÏùÑ Ìè¨Ìï®Ìï®. LangChain, Google ADK, Crew AI Í∞ôÏùÄ frameworkÎì§ÏùÄ Ïù¥Îü¨Ìïú Ïô∏Î∂Ä toolÏùò ÌÜµÌï©ÏùÑ Ï¥âÏßÑÌïòÎäî Íµ¨Ï°∞ÌôîÎêú Ï∂îÏÉÅÌôî Î∞è Ïª¥Ìè¨ÎÑåÌä∏Î•º Ï†úÍ≥µÌï®. Ïù¥Îü¨Ìïú frameworkÎì§ÏùÄ Î™®Îç∏Ïóê tool ÏÇ¨ÏñëÏùÑ ÎÖ∏Ï∂úÌïòÍ≥† ÌõÑÏÜç tool ÏÇ¨Ïö© ÏöîÏ≤≠ÏùÑ ÌååÏã±ÌïòÎäî ÌîÑÎ°úÏÑ∏Ïä§Î•º Í¥ÄÎ¶¨Ìï®. Ïù¥Îäî Ïô∏Î∂Ä ÎîîÏßÄÌÑ∏ ÌôòÍ≤ΩÍ≥º ÏÉÅÌò∏ÏûëÏö©ÌïòÍ≥† Í∑∏ ÏïàÏóêÏÑú ÌñâÎèôÌï† Ïàò ÏûàÎäî Ï†ïÍµêÌïú agentic ÏãúÏä§ÌÖú Í∞úÎ∞úÏùÑ Îã®ÏàúÌôîÌï®.

# Ï∞∏Í≥†Î¨∏Ìóå

1. LangChain Documentation (Tools): [https://python.langchain.com/docs/integrations/tools/](https://python.langchain.com/docs/integrations/tools/)
2. Google Agent Developer Kit (ADK) Documentation (Tools): [https://google.github.io/adk-docs/tools/](https://google.github.io/adk-docs/tools/)
3. OpenAI Function Calling Documentation: [https://platform.openai.com/docs/guides/function-calling](https://platform.openai.com/docs/guides/function-calling)
4. CrewAI Documentation (Tools): [https://docs.crewai.com/concepts/tools](https://docs.crewai.com/concepts/tools)
